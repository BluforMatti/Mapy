<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="UTF-8" />
  <title>EMC Map Viewer</title>
  <!--
  ===================================================================
                    INTELLIGENCE MAP VIEWER - P≈òEHLED
  ===================================================================
  
  Toto je profesion√°ln√≠ prohl√≠≈æeƒç map s taktick√Ωm HUD stylem.
  
  RYCHL√ù N√ÅVOD PRO √öPRAVY:
  -------------------------
  
  üìÅ SOUBORY MAP:
     - ≈ò√°dek ~343: Upravte pole 'maps' pro p≈ôid√°n√≠/odebr√°n√≠ soubor≈Ø map
     - Aktu√°ln√≠ mapy: ['map1.png']
     - P≈ôidejte dal≈°√≠ n√°zvy soubor≈Ø jako 'mapa2.png', 'mapa3.png' atd.
  
  üé® BARVY A T√âMA:
     - ≈ò√°dky 15-45: Hlavn√≠ barvy pozad√≠ a m≈ô√≠≈æky
     - ≈ò√°dky 225-250: Barvy a styling HUD
     - Hledejte "#4285f4" pro zmƒõnu modr√© barvy
     - Hledejte "#0f1419" pro zmƒõnu tmav√©ho pozad√≠
  
  üñºÔ∏è LOGO:
     - ≈ò√°dek ~375: Zmƒõ≈àte 'transparentlogo.png' na v√°≈° soubor loga
     - ≈ò√°dek ~365: Upravte URL pozv√°nky na Discord
     - ≈ò√°dky 275-320: Styling a velikost kontejneru loga
  
  ‚òï KO-FI:
     - ≈ò√°dek ~364: Zmƒõ≈àte 'https://ko-fi.com/yourusername' na v√°≈° Ko-fi odkaz
     - ≈ò√°dek ~363: Zmƒõ≈àte 'kofi-icon.png' na v√°≈° Ko-fi obr√°zek
     - ≈ò√°dky 285-315: Styling Ko-fi tlaƒç√≠tka v HUD
  
  üìç POI (BODY Z√ÅJMU):
     - ≈ò√°dek ~470: Upravte objekty 'mapPOIs' pro p≈ôid√°n√≠/odebr√°n√≠ POI
     - Ka≈æd√Ω POI m√°: n√°zev, popis, sou≈ôadnice (x, y), obr√°zek
     - POI se zobrazuj√≠ jako b√≠l√© teƒçky s hover efektem
     - Hover zobraz√≠ tooltip s obr√°zkem a informacemi
  
  üìç POZICOV√ÅN√ç:
     - ≈ò√°dky 135-180: Pozice voliƒçe map (aktu√°lnƒõ nad HUD)
     - ≈ò√°dky 70-100: Pozice posuvn√≠ku zoomu (prav√° strana)
     - ≈ò√°dky 225-250: Pozice HUD (spodn√≠ li≈°ta)
     - ≈ò√°dky 275-285: Pozice loga (vpravo naho≈ôe)
  
  ‚öôÔ∏è NASTAVEN√ç ZOOMU:
     - ≈ò√°dek 326: Hodnoty min/max posuvn√≠ku (min="20" max="200")
     - ≈ò√°dek 340: Z√°kladn√≠ minim√°ln√≠ hodnota zoomu
     - Logika zoomu je v JavaScriptu (≈ô√°dky 450+)
  
  üéØ N√ÅZEV MAPY:
     - ≈ò√°dek 430: Logika form√°tov√°n√≠ n√°zvu mapy
     - Aktu√°lnƒõ automaticky odeb√≠r√° ƒç√≠sla a p≈ô√≠ponu .png
  
  üì± RESPONZIVN√ç:
     - Vƒõt≈°ina prvk≈Ø pou≈æ√≠v√° fixn√≠ pozicov√°n√≠ pro taktick√Ω HUD pocit
     - Kontejner se automaticky p≈ôizp≈Øsobuje v√Ω≈°ce viewportu
  
  HLAVN√ç SEKCE:
  -------------
  1. ≈ò√°dky 8-320:   CSS Styling (barvy, layout, HUD, logo)
  2. ≈ò√°dky 325-350: HTML Struktura (voliƒç map, logo, HUD)
  3. ≈ò√°dky 355-600: JavaScript Logika (zoom, ta≈æen√≠, naƒç√≠t√°n√≠ map)
  
  ===================================================================
  -->

    <!-- Open Graph / Facebook / Discord -->
  <meta property="og:type" content="website" />
  <meta property="og:url" content="http://emcmaps.eu/emcmaps.html" />
  <meta property="og:title" content="EMC - Map Viewer" />
  <meta property="og:description" content="üó∫Ô∏è Tactical map viewer with real-time coordinates. Professional intelligence interface for mission planning." /> 

  <meta property="og:image:width" content="1200" />
  <meta property="og:image:height" content="630" />
  <meta property="og:site_name" content="European Marine Corps" />
  
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500&display=swap');
    
    body {
      margin: 0;
      background: #0f1419;
      color: #e8eaed;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      overflow: hidden;
      user-select: none;
      position: relative;
      /* Disable right-click context menu globally */
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    /* Subtle grid overlay - simplified */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: 
        linear-gradient(rgba(255, 255, 255, 0.02) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255, 255, 255, 0.02) 1px, transparent 1px);
      background-size: 40px 40px;
      pointer-events: none;
      z-index: -1;
    }

    h1 {
      padding: 20px 30px;
      margin: 0;
      margin-top: 50px;
      user-select: none;
      font-family: 'Inter', sans-serif;
      font-weight: 500;
      font-size: 16px;
      letter-spacing: 0.5px;
      color: #9aa0a6;
      border-left: 3px solid #4285f4;
      background: rgba(66, 133, 244, 0.05);
    }

    #container {
      width: 100vw;
      height: calc(100vh - 80px);
      overflow: hidden;
      position: relative;
      cursor: grab;
      display: flex;
      justify-content: center;
      align-items: center;
      border: 1px solid rgba(255, 255, 255, 0.1);
      margin-top: 10px;
      background: rgba(0, 0, 0, 0.2);
      /* Allow pointer events on container for interaction */
      pointer-events: auto;
    }

    /* Invisible watermark overlay */
    #container::after {
      content: 'EUROPEAN MARINE CORPS';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) rotate(-45deg);
      font-family: 'JetBrains Mono', monospace;
      font-size: 24px;
      font-weight: bold;
      color: rgba(255, 255, 255, 0.03);
      pointer-events: none;
      z-index: 50;
      white-space: nowrap;
      user-select: none;
    }

    #map {
      position: absolute;
      top: 50%;
      left: 50%;
      transform-origin: center center;
      transition: transform 0.05s ease-out;
      max-width: none;
      user-select: none;
      border-radius: 4px;
      pointer-events: none; /* Disable right-click and drag-to-save */
      -webkit-user-drag: none; /* Disable dragging in WebKit browsers */
      -khtml-user-drag: none;
      -moz-user-drag: none;
      -o-user-drag: none;
      -webkit-touch-callout: none; /* Disable touch callout on mobile */
    }

    #slider-container {
      position: fixed;
      top: 50%;
      right: 24px;
      transform: translateY(-50%);
      height: 200px;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 16px 12px;
    }

    #slider-container::before {
      content: 'ZOOM';
      font-family: 'JetBrains Mono', monospace;
      font-weight: 500;
      font-size: 10px;
      color: #9aa0a6;
      letter-spacing: 1px;
      margin-bottom: 12px;
    }

    #zoomSlider {
      writing-mode: vertical-lr;
      appearance: none;
      -webkit-appearance: none;
      width: 4px;
      height: 160px;
      background: linear-gradient(to top, rgba(66, 133, 244, 0.3) 0%, #4285f4 100%);
      border-radius: 2px;
      outline: none;
      border: none;
      transform: rotate(180deg);
    }

    #zoomSlider::-webkit-slider-thumb {
      appearance: none;
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #4285f4;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid #1a1f2e;
    }

    #zoomSlider::-webkit-slider-thumb:hover {
      background: #5c94f5;
    }

    #zoomSlider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: #4285f4;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid #1a1f2e;
    }

    /* Elegant unified map selector */
    #mapSelector {
      position: fixed;
      bottom: 80px;
      left: 24px;
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      cursor: pointer;
      font-family: 'Inter', sans-serif;
      font-weight: 500;
      font-size: 13px;
      letter-spacing: 0.5px;
      user-select: none;
      z-index: 1001;
      transition: all 0.3s ease;
      backdrop-filter: blur(8px);
      padding: 14px 20px;
      display: flex;
      align-items: center;
      gap: 12px;
      min-width: 150px;
    }

    #mapSelector:hover {
      background: rgba(66, 133, 244, 0.1);
      border-color: rgba(66, 133, 244, 0.3);
      transform: translateY(-2px);
    }

    #mapSelector.open {
      flex-direction: column;
      align-items: stretch;
      padding: 16px;
      min-width: 200px;
      gap: 8px;
    }

    #mapSelectorCurrent {
      display: flex;
      align-items: center;
      gap: 8px;
      color: #e8eaed;
    }

    #mapSelectorCurrent::before {
      content: 'üó∫Ô∏è';
      font-size: 14px;
    }

    #mapSelectorDropdown {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    #mapSelector.open #mapSelectorDropdown {
      max-height: 300px;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    .mapOption {
      padding: 8px 12px;
      border-radius: 6px;
      margin-bottom: 4px;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
      color: #9aa0a6;
    }

    .mapOption:hover {
      background: rgba(66, 133, 244, 0.1);
      color: #4285f4;
    }

    .mapOption.selected {
      background: rgba(66, 133, 244, 0.2);
      color: #4285f4;
    }

    .mapOption img {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      opacity: 0.7;
    }

    .mapOption:hover img,
    .mapOption.selected img {
      opacity: 1;
    }

    /* Minimal HUD */
    #tacticalHUD {
      position: fixed;
      bottom: 24px;
      left: 24px;
      right: 24px;
      height: 44px;
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: #9aa0a6;
    }

    #coordinates, #zoomLevel, #status {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 400;
    }

    /* Ko-fi button in HUD */
    #kofiButton {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: rgba(255, 95, 95, 0.1);
      border: 1px solid rgba(255, 95, 95, 0.2);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-decoration: none;
      color: #ff5f5f;
      font-size: 11px;
      font-weight: 500;
    }

    #kofiButton:hover {
      background: rgba(255, 95, 95, 0.2);
      border-color: rgba(255, 95, 95, 0.4);
      transform: translateY(-1px);
    }

    #kofiButton img {
      width: 16px;
      height: 16px;
      opacity: 0.8;
    }

    #kofiButton:hover img {
      opacity: 1;
    }

    #coordinates::before {
      content: 'POS:';
      color: #4285f4;
      font-weight: 500;
    }

    #zoomLevel::before {
      content: 'SCALE:';
      color: #4285f4;
      font-weight: 500;
    }

    #status::before {
      content: 'STATUS:';
      color: #4285f4;
      font-weight: 500;
    }

    /* Logo container */
    #logoContainer {
      position: fixed;
      top: 20px;
      right: 24px;
      width: 120px;
      height: 120px;
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1001;
      transition: border-color 0.2s ease, transform 0.2s ease;
      cursor: pointer;
    }

    #logoContainer:hover {
      border-color: rgba(66, 133, 244, 0.3);
      transform: scale(1.05);
    }

    #logoContainer img {
      max-width: 200px;
      max-height: 200px;
      opacity: 0.8;
      transition: opacity 0.2s ease;
    }

    #logoContainer img:hover {
      opacity: 1;
    }

    /* Placeholder for when no logo is loaded */
    #logoContainer::before {
      content: 'LOGO';
      font-family: 'JetBrains Mono', monospace;
      font-size: 10px;
      color: #4285f4;
      font-weight: 500;
      letter-spacing: 1px;
      opacity: 0.5;
    }

    #logoContainer img {
      display: none; /* Hidden by default until logo is loaded */
    }

    #logoContainer.has-logo::before {
      display: none; /* Hide placeholder when logo is present */
    }

    #logoContainer.has-logo img {
      display: block; /* Show logo when loaded */
    }

    /* POI (Points of Interest) Styling */
    .poi {
      position: absolute;
      width: 8px;
      height: 8px;
      background: rgba(255, 255, 255, 0.9);
      border: 2px solid rgba(66, 133, 244, 0.8);
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.2s ease;
      z-index: 100;
      transform: translate(-50%, -50%);
    }

    .poi:hover {
      background: #4285f4;
      border-color: rgba(255, 255, 255, 0.9);
      transform: translate(-50%, -50%) scale(1.5);
      box-shadow: 0 0 12px rgba(66, 133, 244, 0.6);
    }

    .poi-tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      padding: 12px;
      min-width: 200px;
      max-width: 300px;
      z-index: 1000;
      pointer-events: none;
      opacity: 0;
      transform: translateY(10px);
      transition: all 0.2s ease;
      font-family: 'Inter', sans-serif;
      backdrop-filter: blur(8px);
    }

    .poi-tooltip.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .poi-tooltip img {
      width: 100%;
      height: 120px;
      object-fit: cover;
      border-radius: 4px;
      margin-bottom: 8px;
    }

    .poi-tooltip h3 {
      margin: 0 0 4px 0;
      color: #4285f4;
      font-size: 14px;
      font-weight: 600;
    }

    .poi-tooltip p {
      margin: 0;
      color: #9aa0a6;
      font-size: 12px;
      line-height: 1.4;
    }
  </style>
</head>
<body>
  <div id="mapSelector">
    <div id="mapSelectorCurrent">Select Map</div>
    <div id="mapSelectorDropdown"></div>
  </div>

  <div id="logoContainer">
    <img id="logo" alt="Agency Logo" />
  </div>

  <h1 id="mapTitle">Initializing secure connection...</h1>

  <div id="container">
    <img id="map" alt="Intelligence Map" />
  </div>

  <div id="slider-container">
    <input
      type="range"
      id="zoomSlider"
      min="20"
      max="200"
      value="75"
      step="1"
    />
  </div>

  <div id="tacticalHUD">
    <div id="coordinates">0, 0</div>
    <div id="zoomLevel">100%</div>
    <div id="status">Standby</div>
    <a id="kofiButton" href="https://ko-fi.com/matti12816" target="_blank">
      <img src="kofi.png" alt="Ko-fi" />
      <span>Support</span>
    </a>
  </div>

  <script>
    // ===================================================================
    //                    OCHRANA PROTI STAHOV√ÅN√ç MAP
    // ===================================================================
    
    // Detekce podez≈ôel√© aktivity (rychl√© kl√°vesy, automatizovan√© chov√°n√≠)
    let suspiciousActivity = 0;
    let lastKeyTime = 0;
    
    function detectSuspiciousActivity() {
      suspiciousActivity++;
      if (suspiciousActivity > 10) {
        console.log('Suspicious activity detected - possible automation');
        // M≈Ø≈æete p≈ôidat redirect nebo jin√© opat≈ôen√≠
        document.body.style.filter = 'blur(20px)';
        setTimeout(() => {
          document.body.style.filter = 'none';
          suspiciousActivity = 0;
        }, 5000);
      }
    }

    // Zak√°z√°n√≠ prav√©ho kliknut√≠ (kontextov√©ho menu) na cel√© str√°nce
    document.addEventListener('contextmenu', function(e) {
      e.preventDefault();
      return false;
    }, false);
    
    // Zak√°z√°n√≠ F12 (Developer Tools) a dal≈°√≠ch kl√°vesov√Ωch zkratek
    document.addEventListener('keydown', function(e) {
      const currentTime = Date.now();
      // Detekce rychl√©ho maƒçk√°n√≠ kl√°ves (mo≈æn√Ω bot)
      if (currentTime - lastKeyTime < 50) {
        detectSuspiciousActivity();
      }
      lastKeyTime = currentTime;
      
      // F12, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+U, Ctrl+Shift+C
      if (e.keyCode === 123 || // F12
          (e.ctrlKey && e.shiftKey && e.keyCode === 73) || // Ctrl+Shift+I
          (e.ctrlKey && e.shiftKey && e.keyCode === 74) || // Ctrl+Shift+J
          (e.ctrlKey && e.keyCode === 85) || // Ctrl+U (view source)
          (e.ctrlKey && e.shiftKey && e.keyCode === 67) || // Ctrl+Shift+C
          (e.ctrlKey && e.keyCode === 83) || // Ctrl+S (save page)
          (e.key === 'F12') || // Alternative F12 detection
          (e.ctrlKey && e.keyCode === 80)) { // Ctrl+P (print)
        e.preventDefault();
        detectSuspiciousActivity();
        return false;
      }
    }, false);
    
    // Zak√°z√°n√≠ v√Ωbƒõru textu a ta≈æen√≠ obr√°zk≈Ø
    document.addEventListener('selectstart', function(e) {
      e.preventDefault();
      return false;
    }, false);
    
    document.addEventListener('dragstart', function(e) {
      e.preventDefault();
      return false;
    }, false);
    
    // Detekce otev≈ôen√≠ Developer Tools (nep≈ôesn√©, ale ƒç√°steƒçnƒõ √∫ƒçinn√©)
    let devtools = {open: false, orientation: null};
    const threshold = 160;
    
    setInterval(() => {
      if (window.outerHeight - window.innerHeight > threshold || 
          window.outerWidth - window.innerWidth > threshold) {
        if (!devtools.open) {
          devtools.open = true;
          // M≈Ø≈æete zde p≈ôidat redirect nebo jin√© opat≈ôen√≠
          console.clear();
          console.log('%cDeveloper tools detected!', 'color: red; font-size: 20px;');
          // Blur obsah p≈ôi otev≈ôen√≠ dev tools
          document.body.style.filter = 'blur(10px)';
          document.body.style.pointerEvents = 'none';
        }
      } else {
        if (devtools.open) {
          // Obnoven√≠ p≈ôi zav≈ôen√≠ dev tools
          document.body.style.filter = 'none';
          document.body.style.pointerEvents = 'auto';
        }
        devtools.open = false;
      }
    }, 500);
    
    // Pravideln√© maz√°n√≠ console
    setInterval(() => {
      console.clear();
    }, 2000);
    
    // Ochrana proti print screen (ƒç√°steƒçn√° - nelze √∫plnƒõ zabr√°nit)
    document.addEventListener('keyup', function(e) {
      if (e.keyCode === 44) { // Print Screen
        console.log('Print screen detected');
        // Doƒçasn√© skryt√≠ obsahu
        document.body.style.visibility = 'hidden';
        setTimeout(() => {
          document.body.style.visibility = 'visible';
        }, 100);
      }
    }, false);

    // Detekce tab visibility (p≈ôi p≈ôepnut√≠ do jin√© aplikace pro screenshot)
    document.addEventListener('visibilitychange', function() {
      if (document.hidden) {
        // Str√°nka nen√≠ viditeln√° - mo≈æn√Ω screenshot
        console.log('Page hidden - potential screenshot attempt');
        detectSuspiciousActivity();
      }
    });

    // Online-specific protection: Referrer checking
    if (document.referrer && !document.referrer.includes(window.location.hostname)) {
      console.log('External referrer detected:', document.referrer);
      // M≈Ø≈æete p≈ôidat kontrolu povolen√Ωch dom√©n
    }

    // Detekce automatizace (headless browsers, selenium)
    function detectAutomation() {
      // Kontrola typick√Ωch znak≈Ø automatizace
      if (navigator.webdriver || 
          window.callPhantom || 
          window._phantom || 
          window.__selenium_unwrapped ||
          window.__webdriver_evaluate ||
          window.__webdriver_script_function) {
        console.log('Automation detected');
        document.body.style.display = 'none';
        return true;
      }
      
      // Kontrola neobvykl√Ωch vlastnost√≠
      if (navigator.languages && navigator.languages.length === 0) {
        console.log('Suspicious browser detected');
        return true;
      }
      
      return false;
    }

    // Spu≈°tƒõn√≠ detekce automatizace
    if (detectAutomation()) {
      document.body.innerHTML = '<h1>Access Denied</h1>';
    }

    const map = document.getElementById('map');
    const container = document.getElementById('container');
    const zoomSlider = document.getElementById('zoomSlider');
    const mapSelector = document.getElementById('mapSelector');
    const mapSelectorCurrent = document.getElementById('mapSelectorCurrent');
    const mapSelectorDropdown = document.getElementById('mapSelectorDropdown');
    const mapTitle = document.getElementById('mapTitle');

    let scale = 1;
    let pos = { x: 0, y: 0 };
    let dragStart = { x: 0, y: 0 };
    let isDragging = false;
    let centeredAtMinZoom = true;
    let currentMinZoom = 20; // Dynamic minimum zoom based on current image

    const baseMinZoomValue = Number(zoomSlider.min); // 20 - base minimum
    const maxZoomValue = Number(zoomSlider.max); // 200

    // Seznam map
    const maps = [
      'map1.png'
    ];

    // Funkce pro obfuskaci n√°zvu souboru (zt√≠≈æen√≠ identifikace v network tabu)
    // Zak√≥duje n√°zev souboru do Base64 a p≈ôid√° n√°hodn√Ω timestamp
    function obfuscateImagePath(imageName) {
      const timestamp = Date.now();
      const randomSeed = Math.random().toString(36).substring(7);
      const encodedName = btoa(imageName); // Base64 encode
      const userAgent = btoa(navigator.userAgent.substring(0, 20)); // Browser fingerprint
      return `${imageName}?v=${encodedName}&t=${timestamp}&r=${randomSeed}&ua=${userAgent}&ref=${btoa(document.referrer || 'direct')}`;
    }

    // Funkce pro vytvo≈ôen√≠ "dummy" request≈Ø (zt√≠≈æen√≠ identifikace skuteƒçn√Ωch map)
    function createDecoyRequests() {
      const decoyNames = ['decoy1.png', 'decoy2.png', 'background.png', 'overlay.png', 'thumb.jpg', 'preview.png'];
      decoyNames.forEach(name => {
        const img = new Image();
        img.style.display = 'none';
        // Tyto requesty sel≈æou, ale vytvo≈ô√≠ "≈°um" v network tabu
        img.src = name + '?decoy=' + Math.random() + '&fake=' + Date.now();
        // P≈ôid√°me random delay pro realistiƒçtƒõj≈°√≠ "≈°um"
        setTimeout(() => {
          img.src = name + '?decoy2=' + Math.random();
        }, Math.random() * 1000);
      });
    }

    // Detekce podez≈ôel√© aktivity (rychl√© kl√°vesy, automatizovan√© chov√°n√≠)
    function detectSuspiciousActivity() {
      suspiciousActivity++;
      if (suspiciousActivity > 10) {
        console.log('Suspicious activity detected - possible automation');
        // M≈Ø≈æete p≈ôidat redirect nebo jin√© opat≈ôen√≠
        document.body.style.filter = 'blur(20px)';
        setTimeout(() => {
          document.body.style.filter = 'none';
          suspiciousActivity = 0;
        }, 5000);
      }
    }

    // POI data for each map
    // Format: 'mapfilename.png': [ array of POI objects ]
    // Each POI object has:
    // - name: N√°zev POI (zobraz√≠ se v tooltip)
    // - description: Popis POI (zobraz√≠ se pod n√°zvem)
    // - x: Pozice X na obr√°zku v pixelech (mƒõ≈ôeno zleva)
    // - y: Pozice Y na obr√°zku v pixelech (mƒõ≈ôeno shora)
    // - image: Cesta k obr√°zku POI (zobraz√≠ se v tooltip)
    const mapPOIs = {
      'map1.png': [
        {
          name: 'V√Ωchodn√≠ vƒõ≈æ',
          description: 'Strategick√° pozorovac√≠ vƒõ≈æ s v√Ωhledem na cel√© √∫dol√≠.',
          x: 300, // pozice X na obr√°zku (v pixelech) - 300px zleva
          y: 150, // pozice Y na obr√°zku (v pixelech) - 150px shora
          image: 'poi1.jpg' // obr√°zek POI - mus√≠ b√Ωt ve stejn√© slo≈æce
        },
        {
          name: 'Hlavn√≠ z√°kladna',
          description: 'Velitelsk√© centrum s komunikaƒçn√≠m za≈ô√≠zen√≠m.',
          x: 500, // 500px zleva
          y: 400, // 400px shora
          image: 'poi2.jpg'
        },
        {
          name: 'P≈ôist√°vac√≠ plocha',
          description: 'Heliport pro rychl√© nasazen√≠ a evakuaci.',
          x: 200, // 200px zleva
          y: 300, // 300px shora
          image: 'poi3.jpg'
        }
        // Pro p≈ôid√°n√≠ dal≈°√≠ho POI zkop√≠rujte jeden z objekt≈Ø v√Ω≈°e
        // a zmƒõ≈àte jeho hodnoty (nezapome≈àte na ƒç√°rku mezi objekty)
      ]
      // Pro p≈ôid√°n√≠ POI na dal≈°√≠ mapy p≈ôidejte nov√Ω kl√≠ƒç:
      // 'nazev_mapy.png': [
      //   { name: 'POI n√°zev', description: 'popis', x: 100, y: 200, image: 'obr.jpg' }
      // ],
    };

    // HUD elementy
    const coordinatesDisplay = document.getElementById('coordinates');
    const zoomLevelDisplay = document.getElementById('zoomLevel');
    const statusDisplay = document.getElementById('status');
    const logoContainer = document.getElementById('logoContainer');
    const logoImg = document.getElementById('logo');

    // Logo functionality
    function loadLogo(logoPath) {
      if (logoPath) {
        logoImg.src = logoPath;
        logoImg.onload = () => {
          logoContainer.classList.add('has-logo');
        };
        logoImg.onerror = () => {
          logoContainer.classList.remove('has-logo');
        };
      }
    }

    // Discord invite functionality
    logoContainer.addEventListener('click', () => {
      // Replace 'YOUR_DISCORD_INVITE_CODE' with your actual Discord invite code
      const discordInvite = 'https://discord.gg/cpcyqtVhen';
      window.open(discordInvite, '_blank');
    });

    // Automatically load the transparentlogo.png
    loadLogo('transparentlogo.png');

    // POI management variables
    // currentPOIs: Array obsahuj√≠c√≠ v≈°echny aktu√°lnƒõ zobrazen√© POI elementy
    // activeTooltip: Reference na aktu√°lnƒõ zobrazen√Ω tooltip (nebo null)
    let currentPOIs = [];
    let activeTooltip = null;

    // Funkce pro vytvo≈ôen√≠ jednoho POI bodu na mapƒõ
    // poiData: objekt s daty POI (name, description, x, y, image)
    // Vrac√≠: DOM element POI bodu
    function createPOI(poiData) {
      // Vytvo≈ôen√≠ DOM elementu pro POI bod (b√≠l√° teƒçka s modr√Ωm okrajem)
      const poi = document.createElement('div');
      poi.className = 'poi';
      // Nastaven√≠ pozice POI na mapƒõ (pozice jsou v pixelech relativnƒõ k obr√°zku)
      poi.style.left = poiData.x + 'px';
      poi.style.top = poiData.y + 'px';
      
      // Vytvo≈ôen√≠ tooltip elementu (popup s informacemi o POI)
      const tooltip = document.createElement('div');
      tooltip.className = 'poi-tooltip';
      // Naplnƒõn√≠ tooltip obsahem (obr√°zek, n√°zev, popis)
      tooltip.innerHTML = `
        <img src="${poiData.image}" alt="${poiData.name}" onerror="this.style.display='none';">
        <h3>${poiData.name}</h3>
        <p>${poiData.description}</p>
      `;
      
      // Funkce pro aktualizaci pozice tooltip p≈ôi pohybu my≈°i
      // e: mouse event obsahuj√≠c√≠ pozici kurzoru
      const updateTooltipPosition = (e) => {
        // Z√≠sk√°n√≠ pozice kontejneru mapy
        const rect = container.getBoundingClientRect();
        // V√Ωpoƒçet pozice tooltip relativnƒõ ke kontejneru (s offsetem)
        const x = e.clientX - rect.left + 15; // 15px doprava od kurzoru
        const y = e.clientY - rect.top - 10;  // 10px nahoru od kurzoru
        
        // Nastaven√≠ pozice tooltip
        tooltip.style.left = x + 'px';
        tooltip.style.top = y + 'px';
        
        // Kontrola, zda tooltip nevyl√©z√° z okna - pokud ano, p≈ôesuneme ho
        const tooltipRect = tooltip.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();
        
        // Pokud tooltip vyl√©z√° doprava, posuneme ho doleva od kurzoru
        if (tooltipRect.right > containerRect.right) {
          tooltip.style.left = (x - tooltipRect.width - 30) + 'px';
        }
        // Pokud tooltip vyl√©z√° nahoru, posuneme ho dol≈Ø od kurzoru
        if (tooltipRect.top < containerRect.top) {
          tooltip.style.top = (y + 20) + 'px';
        }
      };
      
      // Event listener: kdy≈æ my≈° najede na POI bod
      poi.addEventListener('mouseenter', (e) => {
        // Pokud je u≈æ nƒõjak√Ω tooltip zobrazen√Ω, odstran√≠me ho
        if (activeTooltip) {
          activeTooltip.remove();
        }
        // P≈ôid√°me nov√Ω tooltip do kontejneru
        container.appendChild(tooltip);
        // Nastav√≠me pozici tooltip
        updateTooltipPosition(e);
        // Zobraz√≠me tooltip s mal√Ωm zpo≈ædƒõn√≠m pro plynulou animaci
        setTimeout(() => tooltip.classList.add('visible'), 10);
        // Ulo≈æ√≠me referenci na aktivn√≠ tooltip
        activeTooltip = tooltip;
      });
      
      // Event listener: kdy≈æ se my≈° pohybuje nad POI bodem
      // (tooltip sleduje kurzor)
      poi.addEventListener('mousemove', updateTooltipPosition);
      
      // Event listener: kdy≈æ my≈° opust√≠ POI bod
      poi.addEventListener('mouseleave', () => {
        if (activeTooltip) {
          // Skryjeme tooltip (odebereme CSS t≈ô√≠du 'visible')
          activeTooltip.classList.remove('visible');
          // Po dokonƒçen√≠ animace tooltip √∫plnƒõ odstran√≠me
          setTimeout(() => {
            if (activeTooltip && activeTooltip.parentNode) {
              activeTooltip.remove();
            }
            activeTooltip = null;
          }, 200); // 200ms = doba animace skryt√≠
        }
      });
      
      // Vr√°t√≠me vytvo≈ôen√Ω POI element
      return poi;
    }

    // Funkce pro naƒçten√≠ a zobrazen√≠ v≈°ech POI pro danou mapu
    // mapName: n√°zev souboru mapy (nap≈ô. 'map1.png')
    function loadPOIs(mapName) {
      // Odstranƒõn√≠ v≈°ech aktu√°lnƒõ zobrazen√Ωch POI z mapy
      currentPOIs.forEach(poi => poi.remove());
      currentPOIs = []; // Vypr√°zdnƒõn√≠ pole
      
      // Odstranƒõn√≠ p≈ô√≠padn√©ho aktivn√≠ho tooltip
      if (activeTooltip) {
        activeTooltip.remove();
        activeTooltip = null;
      }
      
      // Naƒçten√≠ POI dat pro danou mapu (pokud existuj√≠)
      const pois = mapPOIs[mapName] || []; // Pokud mapa nem√° POI, pou≈æije se pr√°zdn√© pole
      
      // Vytvo≈ôen√≠ a p≈ôid√°n√≠ ka≈æd√©ho POI na mapu
      pois.forEach(poiData => {
        const poi = createPOI(poiData); // Vytvo≈ôen√≠ POI elementu
        map.appendChild(poi); // P≈ôid√°n√≠ POI do mapy (jako d√≠tƒõ img elementu)
        currentPOIs.push(poi); // Ulo≈æen√≠ reference pro pozdƒõj≈°√≠ odstranƒõn√≠
      });
    }

    // Funkce pro aktualizaci HUD
    function updateHUD() {
      const x = Math.round(pos.x);
      const y = Math.round(pos.y);
      const zoomPercent = Math.round(scale * 100);
      
      coordinatesDisplay.textContent = `${x}, ${y}`;
      zoomLevelDisplay.textContent = `${zoomPercent}%`;
      
      if (scale <= currentMinZoom / 100) {
        statusDisplay.textContent = 'Overview';
      } else if (scale >= 1.5) {
        statusDisplay.textContent = 'Detail view';
      } else {
        statusDisplay.textContent = 'Active';
      }
    }

    function calculateInitialScaleAndPosition() {
      const containerRect = container.getBoundingClientRect();
      const containerWidth = containerRect.width;
      const containerHeight = containerRect.height;

      const imgWidth = map.naturalWidth;
      const imgHeight = map.naturalHeight;

      if (imgWidth === 0 || imgHeight === 0) {
        return { scale: 1, posX: 0, posY: 0 };
      }

      // V√Ωpoƒçet ≈°k√°lov√°n√≠ tak, aby cel√Ω obr√°zek byl viditeln√Ω
      const scaleX = containerWidth / imgWidth;
      const scaleY = containerHeight / imgHeight;
      const fitScale = Math.min(scaleX, scaleY);

      // Pou≈æijeme scale kter√Ω zajist√≠, ≈æe cel√Ω obr√°zek bude viditeln√Ω
      const initialScale = fitScale;

      // Pro centrov√°n√≠ s na≈°√≠m transform syst√©mem pou≈æ√≠v√°me pozici 0,0
      return { scale: initialScale, posX: 0, posY: 0 };
    }

    // Funkce pro naƒçten√≠ mapy p≈ô√≠mo (s obfuskac√≠ a ochranou)
    function loadMap(name) {
      centeredAtMinZoom = true;
      
      // Vytvo≈ôen√≠ decoy request≈Ø pro zt√≠≈æen√≠ identifikace
      createDecoyRequests();
      
      // Obfuskace cesty k obr√°zku
      const obfuscatedPath = obfuscateImagePath(name);
      
      map.src = obfuscatedPath;
      map.onload = () => {
        // Spoƒç√≠t√°me poƒç√°teƒçn√≠ scale a pozici
        const { scale: initialScale, posX, posY } = calculateInitialScaleAndPosition();

        scale = initialScale;
        pos.x = posX;
        pos.y = posY;

        // Vypoƒçteme a nastav√≠me nov√Ω minim√°ln√≠ zoom pro tento obr√°zek
        const containerRect = container.getBoundingClientRect();
        const containerWidth = containerRect.width;
        const containerHeight = containerRect.height;
        const imgWidth = map.naturalWidth;
        const imgHeight = map.naturalHeight;
        
        if (imgWidth > 0 && imgHeight > 0) {
          const scaleX = containerWidth / imgWidth;
          const scaleY = containerHeight / imgHeight;
          const fitScale = Math.min(scaleX, scaleY);
          // Nastav√≠me minim√°ln√≠ zoom na vƒõt≈°√≠ z: base minimum (20) nebo fit-to-screen zoom
          // Ale zajist√≠me, ≈æe nen√≠ p≈ô√≠li≈° mal√Ω (minim√°lnƒõ 10%)
          const calculatedMinZoom = Math.max(baseMinZoomValue, Math.round(fitScale * 100));
          currentMinZoom = Math.max(10, calculatedMinZoom);
          
          // Aktualizujeme slider minimum
          zoomSlider.min = currentMinZoom;
        } else {
          currentMinZoom = baseMinZoomValue;
          zoomSlider.min = baseMinZoomValue;
        }

        // Nastav√≠me slider podle scale (direct value since slider is not rotated)
        let normalValue = Math.round(scale * 100);
        // Zajist√≠me, ≈æe slider value nen√≠ men≈°√≠ ne≈æ jeho minimum
        normalValue = Math.max(normalValue, currentMinZoom);
        zoomSlider.value = normalValue;

        updateTransform();
        // Use the actual map filename (without extension) as the title
        const mapName = name.replace('.png', '').replace(/\d+/g, ' $&').trim();
        mapTitle.textContent = mapName;
        updateSelectedThumb();
        updateHUD();
        
        // D≈ÆLE≈ΩIT√â: Naƒçten√≠ POI pro tuto mapu
        // Toto se vol√° poka≈æd√©, kdy≈æ se naƒçte nov√° mapa
        // Automaticky odstran√≠ star√© POI a naƒçte nov√© podle mapPOIs objektu
        loadPOIs(name);
      };
      map.onerror = () => {
        alert('Error: Map data unavailable');
      };
    }

    // Vytvo≈ôen√≠ n√°hled≈Ø map (pouze pokud je v√≠ce ne≈æ 1 mapa)
    function createMapThumbnails() {
      if (maps.length <= 1) {
        mapSelector.style.display = 'none';
        return;
      }
      
      maps.forEach((name, index) => {
        const option = document.createElement('div');
        option.className = 'mapOption';
        
        const img = document.createElement('img');
        const obfuscatedPath = obfuscateImagePath(name);
        img.src = obfuscatedPath;
        
        const label = document.createElement('span');
        const formattedName = name.replace('.png', '').replace(/\d+/g, ' $&').trim();
        label.textContent = formattedName;
        
        option.appendChild(img);
        option.appendChild(label);
        
        option.addEventListener('click', (e) => {
          e.stopPropagation();
          loadMap(name);
          mapSelector.classList.remove('open');
        });
        
        mapSelectorDropdown.appendChild(option);
        
        // Set first map as selected initially
        if (index === 0) {
          option.classList.add('selected');
          mapSelectorCurrent.textContent = formattedName;
        }
      });
    }

    // Zv√Ωraznƒõn√≠ aktu√°lnƒõ vybran√© mapy v n√°hledech
    function updateSelectedThumb() {
      const currentMapName = mapTitle.textContent;
      const options = mapSelectorDropdown.querySelectorAll('.mapOption');
      options.forEach(option => {
        const optionText = option.querySelector('span').textContent;
        if (optionText === currentMapName) {
          option.classList.add('selected');
          mapSelectorCurrent.textContent = optionText;
        } else {
          option.classList.remove('selected');
        }
      });
    }

    // Aktualizace transformace (posun a zoom)
    function updateTransform() {
      map.style.transform = `translate(-50%, -50%) translate(${pos.x}px, ${pos.y}px) scale(${scale})`;
    }

    // Toggle vysouvac√≠ho panelu map
    mapSelector.addEventListener('click', (e) => {
      // Don't toggle if clicking on a map option
      if (!e.target.closest('.mapOption')) {
        mapSelector.classList.toggle('open');
      }
    });

    zoomSlider.addEventListener('input', () => {
      // Direct slider value since we're not rotating it anymore
      let sliderValue = parseFloat(zoomSlider.value);
      let newScale = sliderValue / 100;
      
      // Pou≈æ√≠v√°me aktu√°ln√≠ minim√°ln√≠ zoom, ale zajist√≠me minim√°lnƒõ 10%
      const effectiveMinZoom = Math.max(10, currentMinZoom);
      const centeringThreshold = effectiveMinZoom * 1.2; // 20% nad minimem zaƒç√≠n√° centrov√°n√≠
      
      if (newScale <= effectiveMinZoom / 100) {
        // Nastav√≠me na "fit to screen" scale
        const containerRect = container.getBoundingClientRect();
        const containerWidth = containerRect.width;
        const containerHeight = containerRect.height;
        const imgWidth = map.naturalWidth;
        const imgHeight = map.naturalHeight;
        
        if (imgWidth > 0 && imgHeight > 0) {
          const scaleX = containerWidth / imgWidth;
          const scaleY = containerHeight / imgHeight;
          const fitScale = Math.min(scaleX, scaleY);
          // Zajist√≠me, ≈æe scale nen√≠ p≈ô√≠li≈° mal√Ω
          scale = Math.max(0.1, fitScale);
        } else {
          scale = Math.max(0.1, effectiveMinZoom / 100);
        }
        pos = { x: 0, y: 0 };
        centeredAtMinZoom = true;
      } else if (newScale <= centeringThreshold / 100) {
        // Postupn√© centrov√°n√≠ mezi threshold a minimem
        const progress = (centeringThreshold / 100 - newScale) / (centeringThreshold / 100 - effectiveMinZoom / 100);
        const smoothProgress = Math.min(1, Math.max(0, progress));
        
        // Interpolace pozice smƒõrem ke st≈ôedu
        pos.x = pos.x * (1 - smoothProgress);
        pos.y = pos.y * (1 - smoothProgress);
        
        if (centeredAtMinZoom) {
          pos.x = 0;
          pos.y = 0;
          centeredAtMinZoom = false;
        }
        scale = Math.max(0.1, newScale);
      } else {
        if (centeredAtMinZoom) {
          pos.x = 0;
          pos.y = 0;
          centeredAtMinZoom = false;
        }
        scale = Math.max(0.1, newScale); // Zajist√≠me minim√°lnƒõ 10%
      }
      
      updateTransform();
      updateHUD();
    });

    container.addEventListener('mousedown', e => {
      // Allow dragging at all zoom levels
      // Prevent default to avoid image dragging and right-click menu
      e.preventDefault();
      
      // Only allow left mouse button for dragging
      if (e.button !== 0) return;
      
      isDragging = true;
      dragStart.x = e.clientX - pos.x;
      dragStart.y = e.clientY - pos.y;
      container.style.cursor = 'grabbing';
      
      // Prevent text selection while dragging
      document.body.style.userSelect = 'none';
    });

    container.addEventListener('mouseup', () => {
      isDragging = false;
      container.style.cursor = 'grab';
      document.body.style.userSelect = '';
    });

    container.addEventListener('mouseleave', () => {
      isDragging = false;
      container.style.cursor = 'grab';
      document.body.style.userSelect = '';
    });

    container.addEventListener('mousemove', e => {
      if (!isDragging) return;
      
      // Allow moving at all zoom levels
      pos.x = e.clientX - dragStart.x;
      pos.y = e.clientY - dragStart.y;
      updateTransform();
      updateHUD();
    });

    // --- ZOOM KOLEƒåKEM kolem kurzoru + vycentrov√°n√≠ p≈ôi odzoomu ---
    container.addEventListener('wheel', e => {
      e.preventDefault();

      let currentValue = parseFloat(zoomSlider.value);
      let delta = e.deltaY < 0 ? 8 : -8; // Normal delta since slider is not rotated
      let newValue = currentValue + delta;
      let maxSliderValue = parseFloat(zoomSlider.max);
      let minSliderValue = parseFloat(zoomSlider.min);
      newValue = Math.min(maxSliderValue, Math.max(minSliderValue, newValue));
      
      // Direct slider value since we're not rotating it anymore
      const newScale = newValue / 100;
      
      const containerRect = container.getBoundingClientRect();
      const cursorX = e.clientX - containerRect.left;
      const cursorY = e.clientY - containerRect.top;
      
      const prevScale = scale;
      const centeringThreshold = currentMinZoom * 1.2; // 20% nad minimem zaƒç√≠n√° centrov√°n√≠

      if (newScale <= currentMinZoom / 100) {
        // Nastav√≠me na "fit to screen" scale
        const containerWidth = containerRect.width;
        const containerHeight = containerRect.height;
        const imgWidth = map.naturalWidth;
        const imgHeight = map.naturalHeight;
        
        if (imgWidth > 0 && imgHeight > 0) {
          const scaleX = containerWidth / imgWidth;
          const scaleY = containerHeight / imgHeight;
          const fitScale = Math.min(scaleX, scaleY);
          scale = Math.max(0.1, fitScale); // Zajist√≠me minim√°lnƒõ 10%
        } else {
          scale = Math.max(0.1, currentMinZoom / 100);
        }
        pos = { x: 0, y: 0 };
        centeredAtMinZoom = true;
      } else if (newScale <= centeringThreshold / 100) {
        // Postupn√© centrov√°n√≠ mezi threshold a minimem
        const progress = (centeringThreshold / 100 - newScale) / (centeringThreshold / 100 - currentMinZoom / 100);
        const smoothProgress = Math.min(1, Math.max(0, progress));
        
        // Interpolace pozice smƒõrem ke st≈ôedu
        pos.x = pos.x * (1 - smoothProgress);
        pos.y = pos.y * (1 - smoothProgress);
        
        centeredAtMinZoom = false;
        scale = Math.max(0.1, newScale);
      } else {
        // Norm√°ln√≠ zoom s kurzorem jako pivot point - OPRAVENO
        // Vypoƒçteme pozici kurzoru relativnƒõ k obr√°zku p≈ôed zoomem
        const containerCenterX = containerRect.width / 2;
        const containerCenterY = containerRect.height / 2;
        
        // Relativn√≠ pozice kurzoru od st≈ôedu kontejneru
        const relativeX = cursorX - containerCenterX;
        const relativeY = cursorY - containerCenterY;
        
        // Pozice kurzoru v sou≈ôadnic√≠ch obr√°zku p≈ôed transformac√≠
        const imageX = (relativeX - pos.x) / prevScale;
        const imageY = (relativeY - pos.y) / prevScale;
        
        // Nov√° pozice po zmƒõnƒõ scale
        const newImageX = imageX * newScale;
        const newImageY = imageY * newScale;
        
        // Uprav√≠me pozici tak, aby bod pod kurzorem z≈Østal na m√≠stƒõ
        pos.x = relativeX - newImageX;
        pos.y = relativeY - newImageY;
        
        centeredAtMinZoom = false;
        scale = Math.max(0.1, newScale);
      }

      zoomSlider.value = newValue;
      updateTransform();
      updateHUD();
    });

    // Inicializace
    createMapThumbnails();
    if (maps.length > 0) {
      loadMap(maps[0]);
    } else {
      mapTitle.textContent = "No missions available";
    }
  </script>
</body>
</html>
